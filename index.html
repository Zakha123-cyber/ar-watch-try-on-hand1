<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Watch Try-On (Mobile Optimized)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video {
            position: absolute;
            transform: scaleX(-1);
            max-width: 100%;
            max-height: 100%;
            z-index: 0;
        }

        #canvas {
            position: absolute;
            transform: scaleX(-1);
            z-index: 2;
            max-width: 100%;
            max-height: 100%;
        }

        #threeCanvas {
            position: absolute;
            transform: scaleX(-1);
            z-index: 1;
            max-width: 100%;
            max-height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
        }

        #status {
            margin-bottom: 15px;
            font-size: 14px;
        }

        .status-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            background: #666;
        }

        .status-dot.active {
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 0;
            width: 100%;
            transition: background 0.3s;
        }

        button:hover {
            background: #1976D2;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
        }

        #debugInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
            max-width: 250px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Loading models...</div>
    </div>

    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="threeCanvas"></canvas>
    </div>

    <div id="controls">
        <h3 style="margin-bottom: 15px;">AR Watch Try-On</h3>
        <div id="status">
            <div class="status-item">
                <div class="status-dot" id="cameraStatus"></div>
                <span>Camera</span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="mediapipeStatus"></div>
                <span>MediaPipe</span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="tfliteStatus"></div>
                <span>Wrist Segmenter</span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="handStatus"></div>
                <span>Hand Detected</span>
            </div>
        </div>

        <div class="slider-container">
            <label>Watch Scale: <span id="scaleValue">0.8</span></label>
            <input type="range" id="scaleSlider" min="0.5" max="2.0" step="0.1" value="0.8">
        </div>

        <div class="slider-container">
            <label>Y Offset: <span id="yOffsetValue">0</span></label>
            <input type="range" id="yOffsetSlider" min="-200" max="200" step="5" value="0">
        </div>

        <div class="slider-container">
            <label>X Offset: <span id="xOffsetValue">0</span></label>
            <input type="range" id="xOffsetSlider" min="-200" max="200" step="5" value="0">
        </div>

        <div class="slider-container">
            <label>Min Wrist Width: <span id="minWristValue">80</span>px</label>
            <input type="range" id="minWristSlider" min="50" max="200" step="10" value="80">
        </div>

        <div class="slider-container">
            <label>Max Wrist Width: <span id="maxWristValue">250</span>px</label>
            <input type="range" id="maxWristSlider" min="150" max="400" step="10" value="250">
        </div>

        <button id="toggleDebug">Toggle Debug</button>
    </div>

    <div id="debugInfo" style="display: none;">
        <div>FPS: <span id="fps">0</span></div>
        <div>Wrist Position: <span id="wristPos">-</span></div>
        <div>Hand Rotation: <span id="handRot">-</span></div>
    </div>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.9/dist/tf-tflite.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257"></script>

    <!-- Three.js with GLTFLoader -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ImageSegmenter, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18";
        window.THREE = THREE;

        // Global variables
        let video, canvas, ctx, threeCanvas;
        let camera, scene, renderer, watchModel;
        let hands, cameraUtils;
        let segmenter;
        let isRunning = false;
        let handDetected = false;
        let debugMode = false;

        // Settings
        let watchScale = 0.8;
        let yOffset = 0;
        let xOffset = 0;

        // Wrist width constraints
        let minWristWidth = 80;
        let maxWristWidth = 250;

        // Smoothing
        let smoothedX = 0;
        let smoothedY = 0;
        let smoothedAngle = 0;
        let smoothedRoll = 0;
        let smoothedScale = 0;
        const smoothingFactor = 0.25;
        const rotationSmoothingFactor = 1;

        // Orientation change detection
        let previousAngle = null;
        const angleChangeThreshold = Math.PI / 3;
        let stabilityFrames = 0;
        const requiredStabilityFrames = 8;
        let isOrientationChanging = false;

        // FPS calculation
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        // Throttling for mobile (15 fps)
        let lastFrameTime = 0;
        const FRAME_INTERVAL = 1000 / 15;

        // Initialize
        async function init() {
            console.log('üöÄ AR Watch Try-On - Initializing (Mobile Optimized)');
            setupElements();
            setupEventListeners();

            try {
                await loadModels();
                await setupCamera();
                await setupThreeJS();
                hideLoading();
                startDetection();
                console.log('‚úÖ Initialization Complete');
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                document.getElementById('loadingText').textContent = 'Error: ' + error.message;
            }
        }

        function setupElements() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            threeCanvas = document.getElementById('threeCanvas');
        }

        function setupEventListeners() {
            document.getElementById('scaleSlider').addEventListener('input', (e) => {
                watchScale = parseFloat(e.target.value);
                document.getElementById('scaleValue').textContent = watchScale.toFixed(1);
            });

            document.getElementById('yOffsetSlider').addEventListener('input', (e) => {
                yOffset = parseInt(e.target.value);
                document.getElementById('yOffsetValue').textContent = yOffset;
            });

            document.getElementById('xOffsetSlider').addEventListener('input', (e) => {
                xOffset = parseInt(e.target.value);
                document.getElementById('xOffsetValue').textContent = xOffset;
            });

            document.getElementById('minWristSlider').addEventListener('input', (e) => {
                minWristWidth = parseInt(e.target.value);
                document.getElementById('minWristValue').textContent = minWristWidth;
                if (minWristWidth >= maxWristWidth) {
                    maxWristWidth = minWristWidth + 50;
                    document.getElementById('maxWristSlider').value = maxWristWidth;
                    document.getElementById('maxWristValue').textContent = maxWristWidth;
                }
            });

            document.getElementById('maxWristSlider').addEventListener('input', (e) => {
                maxWristWidth = parseInt(e.target.value);
                document.getElementById('maxWristValue').textContent = maxWristWidth;
                if (maxWristWidth <= minWristWidth) {
                    minWristWidth = maxWristWidth - 50;
                    document.getElementById('minWristSlider').value = minWristWidth;
                    document.getElementById('minWristValue').textContent = minWristWidth;
                }
            });

            document.getElementById('toggleDebug').addEventListener('click', () => {
                debugMode = !debugMode;
                document.getElementById('debugInfo').style.display = debugMode ? 'block' : 'none';
            });
        }

        async function loadModels() {
            updateLoadingText('Loading wrist segmentation model...');

            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm");
                segmenter = await ImageSegmenter.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "final_forearm (2).tflite", delegate: "GPU" },
                    outputCategoryMask: true,
                    runningMode: "VIDEO"
                });
                document.getElementById('tfliteStatus').classList.add('active');
                console.log('‚úÖ Wrist Segmenter loaded');
            } catch (error) {
                console.warn('‚ö†Ô∏è Segmentation model failed, using fallback');
                segmenter = null;
                document.getElementById('tfliteStatus').style.opacity = '0.3';
            }

            if (!segmenter) {
                document.getElementById('debugInfo').innerHTML += '<div style="color:red;">‚ùå Segmenter tidak aktif (fallback)</div>';
            }
            else {
                document.getElementById('debugInfo').innerHTML += '<div style="color:green;">‚úÖ Segmenter aktif (GPU)</div>';
            }

            updateLoadingText('Loading MediaPipe Hands...');

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandResults);
            document.getElementById('mediapipeStatus').classList.add('active');
            console.log('‚úÖ MediaPipe Hands loaded');
        }

        async function setupCamera() {
            updateLoadingText('Setting up camera...');

            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                }
            });

            video.srcObject = stream;

            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    threeCanvas.width = video.videoWidth;
                    threeCanvas.height = video.videoHeight;

                    document.getElementById('cameraStatus').classList.add('active');
                    console.log(`‚úÖ Camera ready: ${video.videoWidth}x${video.videoHeight}`);
                    resolve();
                };
            });
        }

        async function setupThreeJS() {
            updateLoadingText('Setting up 3D renderer...');

            scene = new THREE.Scene();

            camera = new THREE.OrthographicCamera(
                threeCanvas.width / -2,
                threeCanvas.width / 2,
                threeCanvas.height / 2,
                threeCanvas.height / -2,
                0.1,
                1000
            );
            camera.position.z = 1000;

            renderer = new THREE.WebGLRenderer({
                canvas: threeCanvas,
                alpha: true,
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(threeCanvas.width, threeCanvas.height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 2.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 2.5);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight1.position.set(5, 5, 10);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight2.position.set(-5, 3, 10);
            scene.add(directionalLight2);

            const frontLight = new THREE.DirectionalLight(0xffffff, 2.0);
            frontLight.position.set(0, 0, 10);
            scene.add(frontLight);

            updateLoadingText('Loading watch model...');
            await loadWatchModel();

            console.log('‚úÖ 3D Renderer ready');
        }

        async function loadWatchModel() {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();

                loader.load(
                    "watchCasio.glb",
                    (gltf) => {
                        watchModel = gltf.scene;
                        watchModel.scale.set(0.1, 0.1, 0.1);
                        watchModel.position.set(0, 0, 0);

                        watchModel.traverse((obj) => {
                            if (!obj.isMesh) return;
                            const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                            mats.forEach((m) => {
                                if (!m) return;
                                m.side = THREE.DoubleSide;
                                m.needsUpdate = true;
                            });
                        });

                        watchModel.visible = false;
                        scene.add(watchModel);

                        // Pre-warm
                        watchModel.visible = true;
                        renderer.render(scene, camera);
                        watchModel.visible = false;

                        console.log("‚úÖ Watch model loaded");
                        resolve();
                    },
                    undefined,
                    (error) => {
                        console.error("Watch model loading error:", error);
                        reject(new Error("Failed to load watchCasio.glb"));
                    }
                );
            });
        }

        function startDetection() {
            isRunning = true;
            cameraUtils = new Camera(video, {
                onFrame: async () => {
                    const now = performance.now();
                    if (now - lastFrameTime >= FRAME_INTERVAL) {
                        lastFrameTime = now;
                        await hands.send({ image: video });
                    }
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();

            startRenderLoop();
        }

        function startRenderLoop() {
            function render() {
                if (isRunning && renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
                requestAnimationFrame(render);
            }
            render();
        }

        let currentHandLandmarks = null;

        async function onHandResults(results) {
            if (!isRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                document.getElementById('handStatus').classList.add('active');

                currentHandLandmarks = results.multiHandLandmarks[0];

                if (debugMode) {
                    drawConnectors(ctx, currentHandLandmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                    drawLandmarks(ctx, currentHandLandmarks, { color: '#FF0000', lineWidth: 1 });
                }

                await processWristPosition();
            } else {
                handDetected = false;
                document.getElementById('handStatus').classList.remove('active');
                if (watchModel) watchModel.visible = false;
            }

            updateFPS();
        }

        function clampWristWidth(width) {
            return Math.max(minWristWidth, Math.min(maxWristWidth, width));
        }

        async function processWristPosition() {
            if (!currentHandLandmarks) return;

            let center_x, center_y;

            if (segmenter) {
                try {
                    const startTimeMs = performance.now();
                    const segResult = await segmenter.segmentForVideo(video, startTimeMs);
                    const mask = segResult.categoryMask.getAsUint8Array();
                    const mWidth = segResult.categoryMask.width;
                    const mHeight = segResult.categoryMask.height;

                    // Hitung jumlah piksel yang terdeteksi sebagai pergelangan (nilai 1)
                    let countSeg = 0;
                    for (let i = 0; i < mask.length; i++) {
                        if (mask[i] === 1) countSeg++;
                    }

                    // Tampilkan status di debugInfo jika mode debug aktif
                    if (debugMode) {
                        document.getElementById('debugInfo').innerHTML += `<div>Seg area: ${countSeg} px</div>`;
                    }

                    // Jika tidak ada area terdeteksi, fallback ke landmark
                    if (countSeg === 0) {
                        console.warn('‚ö†Ô∏è Segmentasi tidak mendeteksi area pergelangan, fallback ke landmark');
                        if (debugMode) {
                            document.getElementById('debugInfo').innerHTML += '<div style="color:orange;">‚ö†Ô∏è Seg area kosong, fallback</div>';
                        }
                        return;
                    }

                    let sumX = 0, sumY = 0, count = 0;
                    let minX = mWidth, maxX = 0, minY = mHeight, maxY = 0;
                    let sumX2 = 0, sumY2 = 0, sumXY = 0;

                    if (debugMode) {
                        const imageData = ctx.createImageData(mWidth, mHeight);
                        const data = imageData.data;
                        for (let i = 0; i < mask.length; i++) {
                            if (mask[i] === 1) {
                                const pixelIdx = i * 4;
                                data[pixelIdx] = 34;
                                data[pixelIdx + 1] = 197;
                                data[pixelIdx + 2] = 94;
                                data[pixelIdx + 3] = 180;
                            }
                        }
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = mWidth;
                        tempCanvas.height = mHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.putImageData(imageData, 0, 0);
                        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
                    }

                    for (let i = 0; i < mask.length; i++) {
                        if (mask[i] === 1) {
                            const mx = i % mWidth;
                            const my = Math.floor(i / mWidth);
                            sumX += mx;
                            sumY += my;
                            count++;
                            if (mx < minX) minX = mx;
                            if (mx > maxX) maxX = mx;
                            if (my < minY) minY = my;
                            if (my > maxY) maxY = my;
                            sumX2 += mx * mx;
                            sumY2 += my * my;
                            sumXY += mx * my;
                        }
                    }

                    if (count > 0) {
                        const centerX = sumX / count;
                        const centerY = sumY / count;

                        const segCenterX = centerX * (canvas.width / mWidth);
                        const segCenterY = centerY * (canvas.height / mHeight);

                        const wrist = currentHandLandmarks[0];
                        const wristX = wrist.x * canvas.width;
                        const wristY = wrist.y * canvas.height;

                        const mu20 = (sumX2 / count) - (centerX * centerX);
                        const mu02 = (sumY2 / count) - (centerY * centerY);
                        const mu11 = (sumXY / count) - (centerX * centerY);

                        const segmentationAngle = 0.5 * Math.atan2(2 * mu11, mu20 - mu02);

                        const indexBase = currentHandLandmarks[5];
                        const pinkyBase = currentHandLandmarks[17];

                        const indexX = indexBase.x * canvas.width;
                        const indexY = indexBase.y * canvas.height;
                        const pinkyX = pinkyBase.x * canvas.width;
                        const pinkyY = pinkyBase.y * canvas.height;

                        const segmentationRoll = Math.atan2(pinkyY - indexY, pinkyX - indexX);

                        const sinAngle = Math.abs(Math.sin(segmentationAngle));
                        const cosAngle = Math.abs(Math.cos(segmentationAngle));
                        const isVertical = sinAngle > cosAngle;

                        const segmentationWidth = (maxX - minX) * (canvas.width / mWidth);
                        let finalWristWidth = segmentationWidth;
                        if (isVertical) {
                            finalWristWidth = clampWristWidth(segmentationWidth);
                        }

                        const vecX = wristX - segCenterX;
                        const vecY = wristY - segCenterY;
                        center_x = wristX - 0.3 * vecX;
                        center_y = wristY - 0.3 * vecY;

                        if (debugMode) {
                            const perpX = -vecY;
                            const perpY = vecX;
                            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                            const perpNormX = perpX / perpLength;
                            const perpNormY = perpY / perpLength;

                            ctx.beginPath();
                            ctx.arc(wristX, wristY, 8, 0, 2 * Math.PI);
                            ctx.fillStyle = 'red';
                            ctx.fill();

                            ctx.beginPath();
                            ctx.arc(segCenterX, segCenterY, 6, 0, 2 * Math.PI);
                            ctx.fillStyle = 'blue';
                            ctx.fill();

                            ctx.beginPath();
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(segCenterX, segCenterY);
                            ctx.lineTo(wristX, wristY);
                            ctx.strokeStyle = 'magenta';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.beginPath();
                            ctx.moveTo(center_x - 10, center_y);
                            ctx.lineTo(center_x + 10, center_y);
                            ctx.moveTo(center_x, center_y - 10);
                            ctx.lineTo(center_x, center_y + 10);
                            ctx.strokeStyle = 'yellow';
                            ctx.lineWidth = 3;
                            ctx.stroke();

                            const axisLength = 60;
                            const axisStartX = center_x - perpNormX * axisLength;
                            const axisStartY = center_y - perpNormY * axisLength;
                            const axisEndX = center_x + perpNormX * axisLength;
                            const axisEndY = center_y + perpNormY * axisLength;
                            ctx.beginPath();
                            ctx.moveTo(axisStartX, axisStartY);
                            ctx.lineTo(axisEndX, axisEndY);
                            ctx.strokeStyle = 'orange';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(indexX, indexY);
                            ctx.lineTo(pinkyX, pinkyY);
                            ctx.strokeStyle = 'cyan';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            document.getElementById('wristPos').textContent =
                                `${Math.round(center_x)}, ${Math.round(center_y)}`;
                            document.getElementById('handRot').textContent =
                                `A:${(segmentationAngle * 180 / Math.PI).toFixed(0)}¬∞ R:${(segmentationRoll * 180 / Math.PI).toFixed(0)}¬∞ ${isVertical ? 'V' : 'H'}`;
                        }

                        const rotation = {
                            angle: segmentationAngle,
                            roll: segmentationRoll,
                            wrist: wrist
                        };

                        updateWatchTransform(center_x, center_y, rotation, finalWristWidth, isVertical);
                    } else {
                        // Fallback jika segmentasi gagal
                        const wrist = currentHandLandmarks[0];
                        const indexBase = currentHandLandmarks[5];
                        const pinkyBase = currentHandLandmarks[17];

                        const wristX = wrist.x * canvas.width;
                        const wristY = wrist.y * canvas.height;
                        const indexX = indexBase.x * canvas.width;
                        const indexY = indexBase.y * canvas.height;
                        const pinkyX = pinkyBase.x * canvas.width;
                        const pinkyY = pinkyBase.y * canvas.height;

                        const segCenterX = (indexX + pinkyX) / 2;
                        const segCenterY = (indexY + pinkyY) / 2;

                        const rotation = calculateHandRotation(currentHandLandmarks);
                        const sinAngle = Math.abs(Math.sin(rotation.angle));
                        const cosAngle = Math.abs(Math.cos(rotation.angle));
                        const isVertical = sinAngle > cosAngle;

                        const landmarkDistance = Math.sqrt(
                            Math.pow(pinkyX - indexX, 2) + Math.pow(pinkyY - indexY, 2)
                        );
                        let wristWidth = landmarkDistance * 4;
                        if (isVertical) {
                            wristWidth = clampWristWidth(wristWidth);
                        }

                        const vecX = wristX - segCenterX;
                        const vecY = wristY - segCenterY;
                        center_x = wristX - 0.3 * vecX;
                        center_y = wristY - 0.3 * vecY;

                        if (debugMode) {
                            const perpX = -vecY;
                            const perpY = vecX;
                            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                            const perpNormX = perpX / perpLength;
                            const perpNormY = perpY / perpLength;

                            ctx.beginPath();
                            ctx.arc(segCenterX, segCenterY, 8, 0, 2 * Math.PI);
                            ctx.fillStyle = 'orange';
                            ctx.fill();

                            ctx.beginPath();
                            ctx.arc(wristX, wristY, 6, 0, 2 * Math.PI);
                            ctx.fillStyle = 'red';
                            ctx.fill();

                            ctx.beginPath();
                            ctx.setLineDash([5, 5]);
                            ctx.moveTo(segCenterX, segCenterY);
                            ctx.lineTo(wristX, wristY);
                            ctx.strokeStyle = 'magenta';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.beginPath();
                            ctx.moveTo(center_x - 10, center_y);
                            ctx.lineTo(center_x + 10, center_y);
                            ctx.moveTo(center_x, center_y - 10);
                            ctx.lineTo(center_x, center_y + 10);
                            ctx.strokeStyle = 'yellow';
                            ctx.lineWidth = 3;
                            ctx.stroke();

                            const axisLength = 60;
                            const axisStartX = center_x - perpNormX * axisLength;
                            const axisStartY = center_y - perpNormY * axisLength;
                            const axisEndX = center_x + perpNormX * axisLength;
                            const axisEndY = center_y + perpNormY * axisLength;
                            ctx.beginPath();
                            ctx.moveTo(axisStartX, axisStartY);
                            ctx.lineTo(axisEndX, axisEndY);
                            ctx.strokeStyle = 'orange';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(indexX, indexY);
                            ctx.lineTo(pinkyX, pinkyY);
                            ctx.strokeStyle = 'cyan';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            document.getElementById('wristPos').textContent =
                                `${Math.round(center_x)}, ${Math.round(center_y)}`;
                        }

                        updateWatchTransform(center_x, center_y, rotation, wristWidth, isVertical);
                    }
                } catch (error) {
                    console.error('Segmentation error:', error);
                }
            } else {
                // Fallback menggunakan MediaPipe landmarks
                const wrist = currentHandLandmarks[0];
                const indexBase = currentHandLandmarks[5];
                const pinkyBase = currentHandLandmarks[17];

                const wristX = wrist.x * canvas.width;
                const wristY = wrist.y * canvas.height;
                const indexX = indexBase.x * canvas.width;
                const indexY = indexBase.y * canvas.height;
                const pinkyX = pinkyBase.x * canvas.width;
                const pinkyY = pinkyBase.y * canvas.height;

                const segCenterX = (indexX + pinkyX) / 2;
                const segCenterY = (indexY + pinkyY) / 2;

                const rotation = calculateHandRotation(currentHandLandmarks);
                const landmarkDistance = Math.sqrt(
                    Math.pow(pinkyX - indexX, 2) + Math.pow(pinkyY - indexY, 2)
                );
                const wristWidth = clampWristWidth(landmarkDistance * 2.0);

                const vecX = wristX - segCenterX;
                const vecY = wristY - segCenterY;
                center_x = wristX - 0.3 * vecX;
                center_y = wristY - 0.3 * vecY;

                if (debugMode) {
                    const perpX = -vecY;
                    const perpY = vecX;
                    const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                    const perpNormX = perpX / perpLength;
                    const perpNormY = perpY / perpLength;

                    ctx.beginPath();
                    ctx.arc(segCenterX, segCenterY, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = 'orange';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(wristX, wristY, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(segCenterX, segCenterY);
                    ctx.lineTo(wristX, wristY);
                    ctx.strokeStyle = 'magenta';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.beginPath();
                    ctx.moveTo(center_x - 10, center_y);
                    ctx.lineTo(center_x + 10, center_y);
                    ctx.moveTo(center_x, center_y - 10);
                    ctx.lineTo(center_x, center_y + 10);
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    const axisLength = 60;
                    const axisStartX = center_x - perpNormX * axisLength;
                    const axisStartY = center_y - perpNormY * axisLength;
                    const axisEndX = center_x + perpNormX * axisLength;
                    const axisEndY = center_y + perpNormY * axisLength;
                    ctx.beginPath();
                    ctx.moveTo(axisStartX, axisStartY);
                    ctx.lineTo(axisEndX, axisEndY);
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(indexX, indexY);
                    ctx.lineTo(pinkyX, pinkyY);
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    document.getElementById('wristPos').textContent =
                        `${Math.round(center_x)}, ${Math.round(center_y)}`;
                }

                updateWatchTransform(center_x, center_y, rotation, wristWidth, false);
            }
        }

        function calculateHandRotation(landmarks) {
            const wrist = landmarks[0];
            const middleFinger = landmarks[9];

            const wristX = wrist.x * canvas.width;
            const wristY = wrist.y * canvas.height;
            const middleX = middleFinger.x * canvas.width;
            const middleY = middleFinger.y * canvas.height;

            const angle = Math.atan2(middleY - wristY, middleX - wristX);

            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];

            const indexX = indexBase.x * canvas.width;
            const indexY = indexBase.y * canvas.height;
            const pinkyX = pinkyBase.x * canvas.width;
            const pinkyY = pinkyBase.y * canvas.height;

            const roll = Math.atan2(pinkyY - indexY, pinkyX - indexX);

            if (debugMode) {
                document.getElementById('handRot').textContent = `${(angle * 180 / Math.PI).toFixed(1)}¬∞`;
            }

            return { angle, roll, wrist };
        }

        function updateWatchTransform(x, y, rotation, wristWidth, isVertical = false) {
            if (!watchModel) return;

            const scaleFactor = isVertical ? 0.2 : 0.1;

            if (previousAngle !== null) {
                let angleDiff = Math.abs(rotation.angle - previousAngle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

                if (angleDiff > angleChangeThreshold) {
                    if (!isOrientationChanging) {
                        isOrientationChanging = true;
                        stabilityFrames = 0;
                        watchModel.visible = false;
                    }
                }
            }

            previousAngle = rotation.angle;

            if (isOrientationChanging) {
                stabilityFrames++;
                if (stabilityFrames >= requiredStabilityFrames) {
                    isOrientationChanging = false;
                    stabilityFrames = 0;
                    smoothedX = (x - canvas.width / 2) + xOffset;
                    smoothedY = (canvas.height / 2 - y) + yOffset;
                    smoothedAngle = rotation.angle;
                    smoothedRoll = rotation.roll;
                    smoothedScale = wristWidth * 1.2 * scaleFactor * watchScale;
                    watchModel.visible = true;
                }
                return;
            }

            watchModel.visible = true;

            const threeX = (x - canvas.width / 2) + xOffset;
            const threeY = (canvas.height / 2 - y) + yOffset;

            smoothedX = smoothedX * (1 - smoothingFactor) + threeX * smoothingFactor;
            smoothedY = smoothedY * (1 - smoothingFactor) + threeY * smoothingFactor;
            smoothedAngle = smoothedAngle * (1 - rotationSmoothingFactor) + rotation.angle * rotationSmoothingFactor;
            smoothedRoll = smoothedRoll * (1 - rotationSmoothingFactor) + rotation.roll * rotationSmoothingFactor;

            watchModel.position.set(smoothedX, smoothedY, 0);
            watchModel.rotation.x = smoothedAngle + Math.PI;
            watchModel.rotation.y = -smoothedAngle + Math.PI / 2;
            watchModel.rotation.z = -smoothedRoll;

            const targetScale = wristWidth * 1.1 * scaleFactor * watchScale;
            smoothedScale = smoothedScale * (1 - smoothingFactor) + targetScale * smoothingFactor;
            watchModel.scale.set(smoothedScale, smoothedScale, smoothedScale);
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                if (debugMode) {
                    document.getElementById('fps').textContent = fps;
                }
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        init();
    </script>
</body>

</html>